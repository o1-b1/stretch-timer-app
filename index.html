<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Stretch Timer" />
  <title>Stretch Timer v3</title>
  <link rel="manifest" href="manifest.json" />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f3f5f9;
      --panel: #ffffff;
      --panel-elev: #f8fafc;
      --text: #0f172a;
      --muted: #475569;
      --border: rgba(15, 23, 42, 0.16);
      --accent: #0ea5e9;
      --accent-strong: #0284c7;
      --ok: #10b981;
      --danger: #ef4444;
      --shadow: 0 10px 28px rgba(15, 23, 42, 0.09);
      --radius: 18px;
    }

    :root[data-theme="dark"] {
      --bg: #020617;
      --panel: rgba(15, 23, 42, 0.92);
      --panel-elev: #111827;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --border: rgba(148, 163, 184, 0.3);
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --ok: #34d399;
      --danger: #f87171;
      --shadow: 0 14px 30px rgba(2, 6, 23, 0.42);
    }

    @media (prefers-color-scheme: dark) {
      :root:not([data-theme="light"]) {
        --bg: #020617;
        --panel: rgba(15, 23, 42, 0.92);
        --panel-elev: #111827;
        --text: #e2e8f0;
        --muted: #94a3b8;
        --border: rgba(148, 163, 184, 0.3);
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --ok: #34d399;
        --danger: #f87171;
        --shadow: 0 14px 30px rgba(2, 6, 23, 0.42);
      }
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .app-shell {
      max-width: 980px;
      margin: 0 auto;
      padding: 0 14px calc(24px + env(safe-area-inset-bottom));
      display: grid;
      gap: 14px;
    }

    .sticky-header {
      position: sticky;
      top: 0;
      z-index: 30;
      margin: 0 -14px;
      padding: calc(12px + env(safe-area-inset-top)) 14px 12px;
      background: color-mix(in srgb, var(--bg) 92%, transparent);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid var(--border);
    }

    .header-bar {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }

    .header-title {
      margin: 0;
      font-size: clamp(1rem, 3.6vw, 1.2rem);
      font-weight: 700;
    }

    .header-sub {
      margin-top: 4px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .pill {
      padding: 8px 11px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel);
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .stack { display: grid; gap: 12px; }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
    }

    .quick-toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 8px 12px;
      background: var(--panel-elev);
    }

    .meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
      color: var(--muted);
      font-weight: 600;
      font-size: 0.94rem;
    }

    .timer {
      font-size: clamp(3rem, 12vw, 5rem);
      font-variant-numeric: tabular-nums;
      line-height: 1;
      font-weight: 800;
      letter-spacing: 0.03em;
      text-align: center;
    }

    .current-step {
      text-align: center;
      font-size: clamp(1.05rem, 3.3vw, 1.35rem);
      min-height: 2.4em;
    }

    .progress-wrap { display: grid; gap: 7px; }

    .progress-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      color: var(--muted);
      font-weight: 600;
    }

    .progress-bar {
      height: 12px;
      border-radius: 999px;
      overflow: hidden;
      background: color-mix(in srgb, var(--muted) 25%, transparent);
    }

    .progress-bar > span {
      display: block;
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, var(--ok), var(--accent));
      transition: width 0.2s ease;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    button,
    input[type="number"] {
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel-elev);
      color: var(--text);
      font: inherit;
    }

    button {
      padding: 14px 10px;
      font-weight: 700;
      cursor: pointer;
      min-height: 52px;
      -webkit-tap-highlight-color: transparent;
    }

    button:active { transform: scale(0.985); }

    .primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #04263b;
      border-color: color-mix(in srgb, var(--accent) 70%, black);
    }

    .danger {
      color: var(--danger);
      border-color: color-mix(in srgb, var(--danger) 44%, transparent);
    }

    .sub-controls {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
    }

    .check-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    label.setting {
      display: flex;
      gap: 10px;
      align-items: center;
      font-weight: 600;
      color: var(--muted);
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: var(--accent);
    }

    .list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 9px;
    }

    .list-item {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: var(--panel-elev);
    }

    .list-item.active {
      border-color: color-mix(in srgb, var(--accent) 55%, var(--border));
      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--accent) 45%, transparent);
    }

    .step-name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .item-actions {
      display: grid;
      grid-template-columns: 70px repeat(3, auto);
      gap: 6px;
      align-items: center;
    }

    .item-actions input { padding: 8px; text-align: center; }

    .item-actions button {
      min-height: 40px;
      padding: 7px 10px;
      font-size: 0.85rem;
    }

    .completion {
      display: none;
      text-align: center;
      padding: 18px;
      border-radius: 16px;
      border: 1px solid color-mix(in srgb, var(--ok) 40%, var(--border));
      background: color-mix(in srgb, var(--ok) 10%, var(--panel));
    }

    .completion.visible { display: block; }

    .muted { color: var(--muted); }

    @media (max-width: 760px) {
      .controls { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .item-actions { grid-template-columns: 68px repeat(3, auto); }
    }
  </style>
</head>
<body>
  <main class="app-shell">
    <header class="sticky-header">
      <div class="header-bar">
        <div>
          <h1 class="header-title" id="headerStep">Stretch Timer</h1>
          <div class="header-sub" id="status">Ready to start</div>
        </div>
        <div class="pill" id="headerRemaining">--:-- left</div>
      </div>
    </header>

    <section class="card stack">
      <div class="toggle-row">
        <label class="quick-toggle" for="quickModeToggle">
          <input id="quickModeToggle" type="checkbox" />
          Quick Stretch Mode
        </label>
        <div class="muted" id="modeCaption">Mode: Full routine</div>
      </div>

      <div id="timer" class="timer">00:00</div>
      <div id="currentStep" class="current-step">Press Start to begin.</div>

      <div class="progress-wrap">
        <div class="progress-label">
          <span id="stepProgressText">Step 1 of 1</span>
          <span id="stepProgressPercent">0%</span>
        </div>
        <div class="progress-bar" aria-label="Progress through current routine">
          <span id="progressFill"></span>
        </div>
      </div>

      <div class="meta-grid">
        <div id="totals">Total remaining: --:--</div>
        <div id="routineDuration">Routine duration: --:--</div>
      </div>

      <div class="controls">
        <button id="backBtn" type="button">‚èÆ Back</button>
        <button id="startPauseBtn" type="button" class="primary">‚ñ∂ Start</button>
        <button id="nextBtn" type="button">Next ‚è≠</button>
        <button id="restartStepBtn" type="button">‚Ü∫ Restart Step</button>
      </div>

      <div class="sub-controls">
        <button id="resetBtn" type="button" class="danger">Reset Routine</button>
      </div>

      <div class="check-grid">
        <label class="setting" for="autoAdvanceToggle">
          <input id="autoAdvanceToggle" type="checkbox" checked /> Auto-advance steps
        </label>
        <label class="setting" for="vibrateToggle">
          <input id="vibrateToggle" type="checkbox" checked /> Haptics on step complete
        </label>
        <label class="setting" for="soundToggle">
          <input id="soundToggle" type="checkbox" /> Sound on step change
        </label>
        <label class="setting" for="themeToggle">
          <input id="themeToggle" type="checkbox" /> Force dark theme
        </label>
      </div>

      <div id="completionCard" class="completion" aria-live="polite">
        <h2>Routine complete üéâ</h2>
        <p id="completionSummary"></p>
        <button id="startAgainBtn" type="button" class="primary">Start again</button>
      </div>
    </section>

    <section class="card stack">
      <h2 style="margin:0; font-size:1.1rem;">Customize routine</h2>
      <p class="muted" style="margin:0;">Reorder steps and adjust duration in seconds. Changes save automatically.</p>
      <ul id="stepList" class="list"></ul>
    </section>
  </main>

  <script>
    const STORAGE_KEY = 'stretch-timer-settings-v3';

    const DEFAULT_ROUTINES = {
      full: [
        { label: 'Half-Kneeling Hip Flexor ‚Äî Left', seconds: 60 },
        { label: 'Half-Kneeling Hip Flexor ‚Äî Right', seconds: 60 },
        { label: 'Couch Stretch ‚Äî Left', seconds: 60 },
        { label: 'Couch Stretch ‚Äî Right', seconds: 60 },
        { label: 'Hamstring Stretch ‚Äî Left', seconds: 45 },
        { label: 'Hamstring Stretch ‚Äî Right', seconds: 45 },
        { label: 'Figure-4 Glute Stretch ‚Äî Left', seconds: 45 },
        { label: 'Figure-4 Glute Stretch ‚Äî Right', seconds: 45 },
        { label: 'Thoracic Open Book ‚Äî Left', seconds: 40 },
        { label: 'Thoracic Open Book ‚Äî Right', seconds: 40 }
      ],
      quick: [
        { label: 'Hip Flexor Stretch ‚Äî Left', seconds: 45 },
        { label: 'Hip Flexor Stretch ‚Äî Right', seconds: 45 },
        { label: 'Hamstring Stretch ‚Äî Left', seconds: 35 },
        { label: 'Hamstring Stretch ‚Äî Right', seconds: 35 },
        { label: 'Thoracic Open Book ‚Äî Left', seconds: 30 },
        { label: 'Thoracic Open Book ‚Äî Right', seconds: 30 }
      ]
    };

    const els = {
      timer: document.getElementById('timer'),
      currentStep: document.getElementById('currentStep'),
      totals: document.getElementById('totals'),
      routineDuration: document.getElementById('routineDuration'),
      status: document.getElementById('status'),
      progressFill: document.getElementById('progressFill'),
      stepProgressText: document.getElementById('stepProgressText'),
      stepProgressPercent: document.getElementById('stepProgressPercent'),
      headerStep: document.getElementById('headerStep'),
      headerRemaining: document.getElementById('headerRemaining'),
      modeCaption: document.getElementById('modeCaption'),
      stepList: document.getElementById('stepList'),
      completionCard: document.getElementById('completionCard'),
      completionSummary: document.getElementById('completionSummary'),
      quickModeToggle: document.getElementById('quickModeToggle'),
      startPauseBtn: document.getElementById('startPauseBtn'),
      nextBtn: document.getElementById('nextBtn'),
      backBtn: document.getElementById('backBtn'),
      resetBtn: document.getElementById('resetBtn'),
      restartStepBtn: document.getElementById('restartStepBtn'),
      startAgainBtn: document.getElementById('startAgainBtn'),
      autoAdvanceToggle: document.getElementById('autoAdvanceToggle'),
      vibrateToggle: document.getElementById('vibrateToggle'),
      soundToggle: document.getElementById('soundToggle'),
      themeToggle: document.getElementById('themeToggle')
    };

    const state = {
      mode: 'full',
      routines: structuredClone(DEFAULT_ROUTINES),
      stepIndex: 0,
      remaining: 0,
      isRunning: false,
      autoAdvance: true,
      vibrate: true,
      soundOn: false,
      forceDarkTheme: false,
      ticker: null,
      endsAt: 0,
      completed: false,
      completionSeconds: 0,
      audioCtx: null
    };

    function formatClock(totalSeconds) {
      const s = Math.max(0, Math.floor(totalSeconds));
      const min = Math.floor(s / 60).toString().padStart(2, '0');
      const sec = (s % 60).toString().padStart(2, '0');
      return `${min}:${sec}`;
    }

    function currentRoutine() {
      return state.routines[state.mode];
    }

    function currentStep() {
      return currentRoutine()[state.stepIndex];
    }

    function routineTotalSeconds() {
      return currentRoutine().reduce((sum, step) => sum + step.seconds, 0);
    }

    function remainingTotalSeconds() {
      const routine = currentRoutine();
      return routine.slice(state.stepIndex + 1).reduce((sum, step) => sum + step.seconds, 0) + state.remaining;
    }

    function saveSettings() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        mode: state.mode,
        autoAdvance: state.autoAdvance,
        vibrate: state.vibrate,
        soundOn: state.soundOn,
        forceDarkTheme: state.forceDarkTheme,
        routines: state.routines
      }));
    }

    function normalizeRoutine(routine, fallback) {
      if (!Array.isArray(routine) || !routine.length) return fallback;
      return routine
        .map((step, idx) => ({
          label: typeof step.label === 'string' && step.label.trim() ? step.label.trim() : fallback[idx]?.label || `Stretch ${idx + 1}`,
          seconds: Number.isFinite(step.seconds) ? Math.max(5, Math.min(600, Math.round(step.seconds))) : fallback[idx]?.seconds || 30
        }));
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (parsed.mode === 'full' || parsed.mode === 'quick') state.mode = parsed.mode;
        if (typeof parsed.autoAdvance === 'boolean') state.autoAdvance = parsed.autoAdvance;
        if (typeof parsed.vibrate === 'boolean') state.vibrate = parsed.vibrate;
        if (typeof parsed.soundOn === 'boolean') state.soundOn = parsed.soundOn;
        if (typeof parsed.forceDarkTheme === 'boolean') state.forceDarkTheme = parsed.forceDarkTheme;
        if (parsed.routines && typeof parsed.routines === 'object') {
          state.routines.full = normalizeRoutine(parsed.routines.full, DEFAULT_ROUTINES.full);
          state.routines.quick = normalizeRoutine(parsed.routines.quick, DEFAULT_ROUTINES.quick);
        }
      } catch (_) {
        // Ignore invalid settings and continue with defaults.
      }
    }

    function stopTicker() {
      if (state.ticker) {
        clearInterval(state.ticker);
        state.ticker = null;
      }
      state.isRunning = false;
    }

    function playStepTone() {
      if (!state.soundOn) return;
      try {
        if (!state.audioCtx) {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) return;
          state.audioCtx = new Ctx();
        }

        if (state.audioCtx.state === 'suspended') {
          state.audioCtx.resume();
        }

        const ctx = state.audioCtx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 880;
        gain.gain.value = 0.0001;

        osc.connect(gain);
        gain.connect(ctx.destination);

        const now = ctx.currentTime;
        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
        osc.start(now);
        osc.stop(now + 0.12);
      } catch (_) {
        // Keep app silent if WebAudio fails.
      }
    }

    function buzz(pattern = 120) {
      if (!state.vibrate || !navigator.vibrate) return;
      navigator.vibrate(pattern);
    }

    function applyTheme() {
      if (state.forceDarkTheme) {
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        document.documentElement.removeAttribute('data-theme');
      }
    }

    function moveStep(index, direction) {
      const routine = currentRoutine();
      const target = index + direction;
      if (target < 0 || target >= routine.length) return;

      [routine[index], routine[target]] = [routine[target], routine[index]];

      if (state.stepIndex === index) state.stepIndex = target;
      else if (state.stepIndex === target) state.stepIndex = index;

      saveSettings();
      render();
    }

    function updateStepDuration(index, value) {
      const seconds = Math.max(5, Math.min(600, Number(value) || 30));
      const routine = currentRoutine();
      routine[index].seconds = seconds;

      if (index === state.stepIndex) {
        state.remaining = Math.min(state.remaining, seconds) || seconds;
      }

      saveSettings();
      render();
    }

    function buildStepList() {
      const routine = currentRoutine();
      els.stepList.innerHTML = '';

      routine.forEach((step, index) => {
        const li = document.createElement('li');
        li.className = `list-item${index === state.stepIndex ? ' active' : ''}`;

        const info = document.createElement('div');
        const name = document.createElement('div');
        name.className = 'step-name';
        name.textContent = `${index + 1}. ${step.label}`;

        const jump = document.createElement('button');
        jump.type = 'button';
        jump.textContent = 'Jump to step';
        jump.addEventListener('click', () => {
          state.stepIndex = index;
          state.remaining = currentStep().seconds;
          state.completed = false;
          render();
          if (state.isRunning) startTicker();
        });

        info.appendChild(name);
        info.appendChild(jump);

        const actions = document.createElement('div');
        actions.className = 'item-actions';

        const durationInput = document.createElement('input');
        durationInput.type = 'number';
        durationInput.min = '5';
        durationInput.max = '600';
        durationInput.step = '5';
        durationInput.value = String(step.seconds);
        durationInput.setAttribute('aria-label', `Duration in seconds for ${step.label}`);
        durationInput.addEventListener('change', () => updateStepDuration(index, durationInput.value));

        const upBtn = document.createElement('button');
        upBtn.type = 'button';
        upBtn.textContent = '‚Üë Up';
        upBtn.disabled = index === 0;
        upBtn.addEventListener('click', () => moveStep(index, -1));

        const downBtn = document.createElement('button');
        downBtn.type = 'button';
        downBtn.textContent = '‚Üì Down';
        downBtn.disabled = index === routine.length - 1;
        downBtn.addEventListener('click', () => moveStep(index, 1));

        const resetBtn = document.createElement('button');
        resetBtn.type = 'button';
        resetBtn.textContent = 'Reset';
        resetBtn.addEventListener('click', () => {
          const defaults = DEFAULT_ROUTINES[state.mode];
          routine[index].seconds = defaults[index]?.seconds || 30;
          saveSettings();
          render();
        });

        actions.append(durationInput, upBtn, downBtn, resetBtn);
        li.append(info, actions);
        els.stepList.appendChild(li);
      });
    }

    function renderCompletion() {
      els.completionCard.classList.toggle('visible', state.completed);
      if (state.completed) {
        els.completionSummary.textContent = `Great work! Total time stretched: ${formatClock(state.completionSeconds)}.`;
      }
    }

    function render() {
      const routine = currentRoutine();
      const step = currentStep();
      const stepElapsed = step.seconds - state.remaining;
      const stepFraction = step.seconds ? stepElapsed / step.seconds : 0;
      const routineProgress = ((state.stepIndex + Math.max(0, Math.min(1, stepFraction))) / routine.length) * 100;
      const safeProgress = Math.max(0, Math.min(100, routineProgress));

      els.timer.textContent = formatClock(state.remaining);
      els.currentStep.textContent = `${step.label}`;
      els.headerStep.textContent = step.label;
      els.headerRemaining.textContent = `${formatClock(remainingTotalSeconds())} left`;
      els.totals.textContent = `Total remaining: ${formatClock(remainingTotalSeconds())}`;
      els.routineDuration.textContent = `Routine duration: ${formatClock(routineTotalSeconds())}`;
      els.progressFill.style.width = `${safeProgress}%`;
      els.stepProgressText.textContent = `Step ${state.stepIndex + 1} of ${routine.length}`;
      els.stepProgressPercent.textContent = `${Math.round(safeProgress)}%`;
      els.status.textContent = state.completed ? 'Routine complete' : state.isRunning ? 'Running' : 'Paused';
      els.modeCaption.textContent = `Mode: ${state.mode === 'quick' ? 'Quick stretch' : 'Full routine'}`;

      els.startPauseBtn.textContent = state.isRunning ? '‚è∏ Pause' : '‚ñ∂ Start';
      els.autoAdvanceToggle.checked = state.autoAdvance;
      els.vibrateToggle.checked = state.vibrate;
      els.soundToggle.checked = state.soundOn;
      els.themeToggle.checked = state.forceDarkTheme;
      els.quickModeToggle.checked = state.mode === 'quick';

      renderCompletion();
      buildStepList();
      applyTheme();
    }

    function showCompletion() {
      stopTicker();
      state.completed = true;
      state.completionSeconds = routineTotalSeconds();
      state.remaining = 0;
      buzz([80, 30, 120]);
      playStepTone();
      render();
    }

    function nextStep(fromAuto = false) {
      const routine = currentRoutine();
      if (state.stepIndex < routine.length - 1) {
        state.stepIndex += 1;
        state.remaining = currentStep().seconds;
        state.completed = false;
        if (!fromAuto) {
          buzz(80);
          playStepTone();
        }
        render();
        if (state.isRunning || fromAuto) startTicker();
      } else {
        showCompletion();
      }
    }

    function previousStep() {
      if (state.stepIndex > 0) {
        state.stepIndex -= 1;
        state.remaining = currentStep().seconds;
        state.completed = false;
        buzz(70);
        playStepTone();
        render();
        if (state.isRunning) startTicker();
      }
    }

    function onStepFinished() {
      buzz(120);
      playStepTone();
      if (state.autoAdvance) {
        nextStep(true);
      } else {
        stopTicker();
        state.remaining = currentStep().seconds;
        render();
      }
    }

    function startTicker() {
      state.completed = false;
      stopTicker();
      state.isRunning = true;
      state.endsAt = Date.now() + state.remaining * 1000;

      state.ticker = setInterval(() => {
        const secondsLeft = Math.max(0, Math.ceil((state.endsAt - Date.now()) / 1000));
        state.remaining = secondsLeft;
        render();
        if (secondsLeft <= 0) onStepFinished();
      }, 200);
    }

    function resetRoutine() {
      stopTicker();
      state.stepIndex = 0;
      state.remaining = currentStep().seconds;
      state.completed = false;
      render();
    }

    function switchMode(mode) {
      if (state.mode === mode) return;
      state.mode = mode;
      state.stepIndex = 0;
      state.remaining = currentStep().seconds;
      state.completed = false;
      stopTicker();
      saveSettings();
      render();
    }

    els.startPauseBtn.addEventListener('click', () => {
      if (state.isRunning) {
        stopTicker();
        render();
      } else {
        startTicker();
      }
    });

    els.nextBtn.addEventListener('click', () => nextStep(false));
    els.backBtn.addEventListener('click', previousStep);
    els.resetBtn.addEventListener('click', resetRoutine);
    els.restartStepBtn.addEventListener('click', () => {
      state.remaining = currentStep().seconds;
      state.completed = false;
      render();
      if (state.isRunning) startTicker();
    });

    els.startAgainBtn.addEventListener('click', () => {
      state.stepIndex = 0;
      state.remaining = currentStep().seconds;
      state.completed = false;
      render();
    });

    els.autoAdvanceToggle.addEventListener('change', () => {
      state.autoAdvance = els.autoAdvanceToggle.checked;
      saveSettings();
    });

    els.vibrateToggle.addEventListener('change', () => {
      state.vibrate = els.vibrateToggle.checked;
      saveSettings();
    });

    els.soundToggle.addEventListener('change', () => {
      state.soundOn = els.soundToggle.checked;
      saveSettings();
      if (state.soundOn) playStepTone();
    });

    els.themeToggle.addEventListener('change', () => {
      state.forceDarkTheme = els.themeToggle.checked;
      saveSettings();
      applyTheme();
    });

    els.quickModeToggle.addEventListener('change', () => {
      switchMode(els.quickModeToggle.checked ? 'quick' : 'full');
    });

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(() => {});
      });
    }

    loadSettings();
    applyTheme();
    state.remaining = currentStep().seconds;
    render();
  </script>
</body>
</html>
